{
    "collab_server" : "",
    "contents" : "#找出集合的所有元素\ncreateC1 = function(data){\n  itemset = vector()\n  for(line in data){\n    for(item in line){\n      if(!(item %in% itemset)){\n        itemset = c(itemset,item)\n      }\n    }\n  }\n  return(sort(itemset))\n}\n\n#calculate the appointed set's support value\ncalsupport = function(datas,ck,supportthreadhold){\n  DT = data.table(name=list(),value = vector(mode = 'integer'),support = vector(mode = 'numeric'))\n  for (line in datas) {\n    for (eck in ck) {\n      if (length(intersect(eck,line)) > 0) {\n        if (setequal(intersect(eck,line),eck)) {\n          ifmatch = sapply(DT$name,setequal,eck)\n          if (!any(ifmatch)) {\n            DT = rbind(DT,data.table(\n              name = list(eck),value = 1,support = NA\n            ))\n          }\n          else{\n            DT[ifmatch,'value'] = DT[ifmatch,'value'] + 1\n          }\n        }\n      }\n    }\n  }\n  numitems = length(datas)\n  DT[,support:=value/numitems]\n  remainDT = DT[support>supportthreadhold,]\n  return(remainDT)\n}\n\n#从Lk-1 生成Ck\ngenerateC = function(L,k){\n  CK = data.table(name = list())\n  len = length(L)\n  if (len > 1) {\n    for (i in 1:(len-1))\n    {\n      for (j in (i + 1):len) {\n        if (k==2){\n          CK = rbind(CK,data.table(name = list(union(L[[i]],L[[j]]))))\n        }\n        else if (setequal(L[[i]][1:(k - 2)],L[[j]][1:(k - 2)])) {\n          CK = rbind(CK,data.table(name = list(union(L[[i]],L[[j]]))))\n        }\n      }\n    }\n  }\n  return(CK)\n}\n\n#配置测试数据\ndatas = datas_copy[1:30]\nminsupport = 0.2\n\napriori2 = function(datas,minsupport = 0.2){\n  C1 = createC1(datas)  #创建C1\n  #D: [set([1, 3, 4]), set([2, 3, 5]), set([1, 2, 3, 5]), set([2, 5])]\n  L1_supportData = calsupport(datas, C1, minsupport)\n  L = list()\n  L[[1]] = L1_supportData$name\n  #若两个项集的长度为k - 1,则必须前k-2项相同才可连接，即求并集，所以[:k-2]的实际作用为取列表的前k-1个元素\n  k = 2\n  support_data = L1_supportData\n  while(length(L[[k-1]]) > 1){\n    Ck = generateC(L[[k-1]], k)\n    psupportData = calsupport(datas,Ck$name,minsupport)\n    Lk = psupportData$name\n    support_data = rbind(support_data,psupportData)\n    #   supportData.update(supK)\n    L[[k]]=(Lk)\n    k =k+1\n  }\n  return(support_data)\n}\n\nsingleset = function(freq){\n  l = list()\n  i=1\n  for(e in freq){\n    l[[i]] = e\n    i = i+1\n  }\n  return(l)\n}\n\nH = singleset(c(\"主APP首页\", \"商场主页\"))\nfreqSet = c(\"主APP首页\", \"商场主页\")\n\ncalcConf = function(freqSet, H, supportData, brl, minConf = 0.2) {\n  prunedH = list()\n  i = 1\n  for (conseq in H) {\n    conf = length(supportData[sapply(sapply(supportData,intersect,freqSet),setequal,freqSet)]) / length(supportData[sapply(sapply(supportData,intersect,setdiff(freqSet,conseq)),setequal,setdiff(freqSet,conseq))])\n    if (conf >= minConf){\n      print(paste0(paste(setdiff(freqSet,conseq),collapse = ','), '-->', paste(conseq,collapse = ','), ' conf:', conf))\n      brl = rbind(brl,(data.table(restset = list(setdiff(freqSet,conseq)), aimset = list(conseq), conf = conf)))\n      prunedH[[i]] = conseq\n      i = i + 1\n    }\n  }\n  #   assign('bigRuleList',brl,pos = 'generateRules')\n  return(list(prunedH,brl))\n}\n\nrulesFromConseq = function(freqSet, H, supportData, brl, minConf=0.2){\n  m = length(H[[1]])\n  while (length(freqSet) > (m)){\n    Hlist = calcConf(freqSet, H, supportData, brl, minConf)\n    H = Hlist[[1]]\n    brl = Hlist[[2]]\n    if (length(H) > 1){\n      H = generateC(H, m + 1)$name\n      m = m+1}\n    else\n      break\n  }\n  return(brl)\n}\n\ngenerateRules = function(L, supportData, minConf = 0.2) {\n  brl = data.table(restset=list(),aimset = list(),conf = vector(mode = 'numeric'))\n  for (i in 1:length(L)) {\n    for (freqSet in L[i]) {\n      H1 = freqSet\n      brl = rulesFromConseq(freqSet, H1, supportData, brl, minConf)\n    }\n  }\n  return(brl)\n}\n\n\n\nhelloword = 'heihei'\n\nhelloworld = function(){\n  helloword = 'buenos dias'\n  print(helloword)\n}\n\n\n# rulesFromConseq_previous = function(freqSet, H, supportData, brl, minConf=0.7){\n#   m = length(H[[1]])\n# if (length(freqSet) > (m + 1)){\n#   Hmpl = generateC(H, m + 1)\n#   Hlist = calcConf(freqSet, Hmpl, supportData, brl, minConf)[[1]]\n#   Hmpl = Hlist[[1]]\n#   brl = Hlist[[2]]\n# if (length(Hmpl) > 1)\n#   rulesFromConseq(freqSet, Hmpl, supportData, brl, minConf)}\n# }\n# \n# bigRuleList = list()\n# generateRules_previous = function(L, supportData, minConf = 0.7) {\n#   for (i in range(1, length(L))) {\n#     for (freqSet in L[i]) {\n#         H1 = freqSet\n#         if (i > 1){\n#           # 三个及以上元素的集合\n#           Hlist = calcConf(freqSet, H1, supportData, bigRuleList, minConf)\n#           H1 = Hlist[[1]]\n#           bigRuleList = Hlistp[[2]]\n#           rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf)\n#           }\n#         else\n#           # 两个元素的集合\n#           calcConf(freqSet, H1, supportData, bigRuleList, minConf)\n#     }\n#   }\n#   return(bigRuleList)\n# }\n",
    "created" : 1498638308478.000,
    "dirty" : false,
    "encoding" : "GB2312",
    "folds" : "",
    "hash" : "1818062157",
    "id" : "A2F78ACB",
    "lastKnownWriteTime" : 1498638348,
    "last_content_update" : 0,
    "path" : "~/Rfile/apriori2.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 22,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}