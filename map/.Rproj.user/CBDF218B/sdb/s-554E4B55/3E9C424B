{
    "collab_server" : "",
    "contents" : "require(sp)\nrequire(spdep)\n\n# Create SpatialPolygonsDataFrame for 3 squares\npoly1 <- Polygons(list(Polygon(matrix(c(15.7,42.3,16.7,42.3,16.7,41.6,15.7,41.6,15.7,42.3), \n                                      nrow=5, ncol=2, byrow=TRUE))),\"1\")     \npoly2 <- Polygons(list(Polygon(matrix(c(15.7,42.3,16.7,42.3,16.7,41.6,15.7,41.6,15.7,42.3)+0.5, \n                                      nrow=5, ncol=2, byrow=TRUE))),\"2\")     \npoly3 <- Polygons(list(Polygon(matrix(c(13.8, 45.4, 15.6, 45.4,15.6, 43.7,13.8, 43.7,13.8, 45.4), \n                                      nrow=5, ncol=2, byrow=TRUE))),\"3\")                      \nspolys = SpatialPolygons(list(poly1,poly2,poly3),1:3)\nspolys <- SpatialPolygonsDataFrame(spolys, data.frame(ID=sapply(slot(spolys, \"polygons\"), \n                                                                function(x) slot(x, \"ID\"))) )   \nproj4string(spolys) <- \"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n\n# Centroid coordinates (not used but provided for example) \ncoords <- coordinates(spolys)\n\n# Create K Nearest Neighbor list\nskNN.nb <- knn2nb(knearneigh(coordinates(spolys), longlat=TRUE), \n                  row.names=spolys@data$ID)\n\n# Calculate maximum distance for all linkages \nmaxDist <- max(unlist(nbdists(skNN.nb, coordinates(spolys), longlat=TRUE)))\n\n# Create spdep distance object\nsDist <- dnearneigh(coordinates(spolys), 0, maxDist^2, row.names=spolys@data$ID)\nsummary(sDist, coordinates(spolys), longlat=TRUE)\n\n# Plot neighbor linkages                  \nplot(spolys, border=\"grey\") \nplot(sDist, coordinates(spolys), add=TRUE)  \n\n# Create neighbor distance list \n( dist.list <- nbdists(sDist, coordinates(spolys), longlat=TRUE) )\n\n# Minimum distance \n( dist.min <- lapply(dist.list, FUN=min) )\n\n# Distance coefficient of variation    \n( dist.cv <- lapply(dist.list, FUN=function(x) { sd(x) / mean(x) } ) )\n\n\n library(geosphere)\n Lon = c(1:9/1000, 1:9/100, 1:9/10, 1:90*2)\n Lat = c(1:9/1000, 1:9/100, 1:9/10, 1:90)\n dcos = distCosine(c(0,0), cbind(Lon, Lat))\n dhav = distHaversine(c(0,0), cbind(Lon, Lat))\n dvsp = distVincentySphere(c(0,0), cbind(Lon, Lat))\n par(mfrow=(c(1,2)))\n plot(log(dcos), dcos-dhav, col='red', ylim=c(-1e-05, 1e-05),\n        xlab=\"Log 'Law of Cosines' distance (m)\",\n        ylab=\"Law of Cosines minus Haversine distance\")\n plot(log(dhav), dhav-dvsp, col='blue',\n        xlab=\"Log 'Haversine' distance (m)\",\n        ylab=\"Vincenty Sphere minus Haversine distance\")\n \n  dvse = distVincentyEllipsoid(c(0,0), cbind(Lon, Lat))\n  plot(dvsp/1000, (dvsp-dvse)/1000, col='blue', xlab='Vincenty Sphere Distance (km)',\n         ylab=\"Difference between 'Vincenty Sphere' and 'Vincenty Ellipsoid' methods (km)\")\n  \n   LA <- c(-118.40, 33.95)\n   NY <- c(-73.78, 40.63)\n   data(wrld)\n   plot(wrld, type='l')\n   gc <- greatCircle(LA, NY)\n   lines(gc, lwd=2, col='blue')\n   gci <- gcIntermediate(LA, NY)\n   lines(gci, lwd=4, col='green')\n   points(rbind(LA, NY), col='red', pch=20, cex=2)\n   mp <- midPoint(LA, NY)\n   onGreatCircle(LA,NY, rbind(mp,c(0,0)))\n   points(mp, pch='*', cex=3, col='orange')\n   gcb = greatCircleBearing(LA, brng=270, n=10)\n   lines(gcb,lwd = 3,col = \"red\")\n   \n    destPoint(LA, b=65, d=100000)\n    circle=destPoint(c(0,80), b=1:365, d=1000000)\n    circle2=destPoint(c(0,80), b=1:365, d=500000)\n    circle3=destPoint(c(0,80), b=1:365, d=100000)\n    plot(circle, type='l')\n    polygon(circle, col='blue', border='black', lwd=4)\n    polygon(circle2, col='red', lwd=4, border='orange')\n    polygon(circle3, col='white', lwd=4, border='black')\n    \n     ml <- gcMaxLat(LA, NY)\n     lat0 <- gcLat(LA, NY, lon=0)\n     lon0 <- gcLon(LA, NY, lat=0)\n     plot(wrld, type='l')\n     lines(gc, lwd=2, col='blue')\n     points(ml, col='red', pch=20, cex=2)\n     points(cbind(0, lat0), pch=20, cex=2, col='yellow')\n     points(t(rbind(lon0, 0)), pch=20, cex=2, col='green')\n     f <- function(lon){gcLat(LA, NY, lon)}\n     opt <- optimize(f, interval=c(-180, 180), maximum=TRUE)\n     points(opt$maximum, opt$objective, pch=20, cex=2, col='dark green' )\n     anti <- antipode(c(opt$maximum, opt$objective))\n     points(anti, pch=20, cex=2, col='dark blue' )\n     \n      SF <- c(-122.44, 37.74)\n      AM <- c(4.75, 52.31)\n      gc2 <- greatCircle(AM, SF)\n      plot(wrld, type='l')\n      lines(gc, lwd=2, col='blue')\n      lines(gc2, lwd=2, col='green')\n      int <- gcIntersect(LA, NY, SF, AM)\n      int\n      antipodal(int[,1:2], int[,3:4])\n     \n      points(rbind(int[,1:2], int[,3:4]), col='red', pch=20, cex=2)\n      bearing1 <- bearing(LA, NY)\n      bearing2 <- bearing(SF, AM)\n      bearing1\n      gcIntersectBearing(LA, bearing1, SF, bearing2)\n      \n      MS <- c(-93.26, 44.98)\n      gc1 <- greatCircleBearing(NY, 281)\n      gc2 <- greatCircleBearing(MS, 195)\n      gc3 <- greatCircleBearing(LA, 55)\n      plot(wrld, type='l', xlim=c(-125, -70), ylim=c(20, 60)) #critical!!\n      lines(gc1, col='green')\n      lines(gc2, col='blue')\n      lines(gc3, col='red')\n      int <- gcIntersectBearing(rbind(NY, NY, MS),\n                                   c(281, 281, 195), rbind(MS, LA, LA), c(195, 55, 55))\n      int\n      \n      distm(rbind(int[,1:2], int[,3:4]))\n      int <- int[,1:2]\n      points(int)\n      poly <- rbind(int, int[1,])\n      centr <- centroid(poly)\n      poly2 <- makePoly(int)\n      polygon(poly2, col='yellow')\n      points(centr, pch='*', col='dark red', cex=2)\n      \n      d = distm(LA,NY)\n      b = bearing(LA,NY)\n      destPoint(LA,b,d)\n      finalBearing(LA,NY)\n      \n      atd <- alongTrackDistance(LA, NY, MS)\n      p <- destPoint(LA, b, atd)\n      plot(wrld, type='l', xlim=c(-130,-60), ylim=c(22,52))\n      lines(gci, col='blue', lwd=2)\n      points(rbind(LA, NY), col='red', pch=20, cex=2)\n      points(MS[1], MS[2], pch=20, col='blue', cex=2)\n      lines(gcIntermediate(LA, p), col='green', lwd=3)\n      lines(gcIntermediate(MS, p), col='dark green', lwd=3)\n      points(p, pch=20, col='red', cex=2)\n      dist2gc(LA, NY, MS)\n      \n      line <- rbind(c(-180,-20), c(-150,-10), c(-140,55), c(10, 0), c(-140,-60))\n      pnts <- rbind(c(-170,0), c(-75,0), c(-70,-10), c(-80,20), c(-100,-50),\n                      + c(-100,-60), c(-100,-40), c(-100,-20), c(-100,-10), c(-100,0))\n      d = dist2Line(pnts, line)\n      plot( makeLine(line), type='l')\n      points(line)\n      points(pnts, col='blue', pch=20)\n      points(d[,2], d[,3], col='red', pch='x', cex=2)\n      for (i in 1:nrow(d)) lines(gcIntermediate(pnts[i,], d[i,2:3], 10), lwd=2, col='green')\n      \n      NP <- c(0, 85)\n      bearing(SF, NP)\n      b <- bearingRhumb(SF, NP)\n      dc <- distCosine(SF, NP)\n      dr = distRhumb(SF,NP)\n      dc/dr\n      \n      pr <- destPointRhumb(SF, b, d=round(dr/100) * 1:100)\n      pc <- rbind(SF, gcIntermediate(SF, NP), NP)\n      par(mfrow=c(1,2))\n      data(wrld)\n      plot(wrld, type='l', xlim=c(-140,10), ylim=c(15,90), main='Equirectangular')\n      lines(pr, col='blue')\n      lines(pc, col='red')\n      data(merc)\n      plot(merc, type='l', xlim=c(-15584729, 1113195),\n              ylim=c(2500000, 22500000), main='Mercator')\n      lines(mercator(pr), col='blue')\n      lines(mercator(pc), col='red')\n      \n      pol <- rbind(c(-120,-20), c(-80,5), c(0, -20), c(-40,-60), c(-120,-20))\n      areaPolygon(pol)\n      perimeter(pol)\n      centroid(pol)\n      span(pol, fun=max)\n      nicepoly = makePoly(pol)\n      plot(pol, xlab='longitude', ylab='latitude', cex=2, lwd=3, xlim=c(-140, 0))\n      lines(wrld, col='grey')\n      lines(pol, col='red', lwd=2)\n      lines(nicepoly, col='blue', lwd=2)\n      points(centroid(pol), pch='*', cex=3, col='dark green')\n      text(centroid(pol)-c(0,2.5), 'centroid')\n      legend(-140, -48, c('planar','spherical'), lty=1, lwd=2,\n                col=c('red', 'blue'), title='polygon type')\n      \n      plot(wrld, type='l', col='grey')\n      a = randomCoordinates(500)\n      points(a, col='blue', pch=20, cex=0.5)\n      b = regularCoordinates(3)\n      points(b, col='red', pch='x')\n      \n      #leaflet plot \n      #http://blog.csdn.net/allenlu2008/article/details/52823492\n      library(leaflet)\n      leaflet()%>%setView(lng=116.38,lat=39.9,zoom=3)%>%\n        addTiles()%>%addProviderTiles(\"Esri.WorldStreetMap\")      \n      leaflet()%>%setView(lng=116.38,lat=39.9,zoom=3)%>%\n        addTiles()%>%addProviderTiles(\"Esri.WorldImagery\")\n      leaflet()%>%setView(lng=116.38,lat=39.9,zoom=3)%>%\n        addTiles()%>%addProviderTiles(\"Esri.WorldTerrain\")\n      leaflet()%>%setView(lng=116.38,lat=39.9,zoom=3)%>%\n        addTiles()%>%addProviderTiles(\"Esri.NatGeoWorldMap\")\n      leaflet()%>%setView(lng=116.38,lat=39.9,zoom=2)%>%\n        addTiles()%>%addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\")\n      \n      leaflet() %>% \n        setView(lng = 110, lat = 30, zoom = 2) %>%\n        addTiles() %>% \n        addProviderTiles(\"NASAGIBS.ModisTerraTrueColorCR\",\n                         options = providerTileOptions(\n                           time = \"2015-01-15\", opacity = 1))\n      \n      leaflet() %>% addTiles() %>% setView(-93.65, 42.0285, zoom = 4) %>%\n        addWMSTiles(\n          \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\",\n          layers = \"nexrad-n0r-900913\",\n          options = WMSTileOptions(format = \"image/png\", transparent = TRUE),\n          attribution = \"Weather data ? 2012 IEM Nexrad\"\n        )\n      \n      #general talking about how to implement maps\n      #http://www.cdadata.com/8040\n      library(maps)\n      map(\"world\", fill = TRUE, col = rainbow(200),ylim = c(-90, 90), mar = c(0, 2, 0, 0))\n      \n      library(sp)\n      # con<-file(\"~/data/map_data/CHN_adm1.rds\")\n      # open(con)#打开链结\n      # print(load(con))\n      # close(con)#关闭链结\n      # spplot(gadm[1])\n      chn_mapdata = readRDS(\"~/data/map_data/CHN_adm0.rds\") \n      spplot(chn_mapdata[1])\n      \n      library(ggmap);\n      map <- get_map(location = 'Zhejiang', zoom = 10, maptype = 'roadmap')\n      ggmap(map)\n      \n      #用googleVis包的另一种方法\n      ##http://www.cdadata.com/8040\n      library(googleVis)\n      provname=c('CN-11','CN-12','CN-13','CN-14','CN-15',\n                  'CN-21','CN-22','CN-23','CN-31','CN-32',\n                  'CN-33','CN-34','CN-35','CN-36','CN-37',\n                  'CN-41','CN-42','CN-43','CN-44','CN-45',\n                  'CN-46','CN-50','CN-51','CN-52','CN-53',\n                  'CN-54','CN-61','CN-62','CN-63','CN-64','CN-65')\n      pop=c(110.56,112.51,113.43,112.52,108.45,112.83,111.23,109.71,110.64,116.51,\n            113.86,127.85,117.93,114.74,112.17,118.46,128.18,126.16,130.30,\n            125.55,135.64,115.13,116.01,107.03,108.71,102.73,122.10,114.82,\n            110.35,108.79,106.12)\n      ##\n      library(googleVis)\n      a<-data.frame(provname,pop)\n      G2 <- gvisGeoChart(a, locationvar='provname', colorvar='pop',options=list(region='CN',displayMode='regions',resolution='provinces',colorAxis='{colors: [\"yellow\",\"red\"]}' ))\n      plot(G2)\n      \n      #Get the world map and select two countries [Colombia and Venezuela]\n      library(maptools) #To get the polygon data \n      data(wrld_simpl)\n      colven <- c(\"Colombia\", \"Venezuela\")\n      colven_map <- wrld_simpl[wrld_simpl$NAME %in% colven, ]\n      \n      # Raster data can be created with this code:\n      library(raster)\n      raster <- raster(colven_map, nrow=100, ncol=100)\n      raster[] <- 1:length(raster)\n      raster_colven <- mask(raster, colven_map)\n      \n      #example data\n      library(maptools) #To get the polygon data \n      data(wrld_simpl)\n      colven <- wrld_simpl[wrld_simpl$NAME %in% c(\"Colombia\", \"Venezuela\"), ]\n      \n      library(raster)\n      raster <- raster(colven, nrow=100, ncol=100)\n      raster[] <- 1:length(raster)\n      raster <- mask(raster, colven)\n      # I create some random cells of interest\n      \n      set.seed(33)\n      cells <- sample(ncell(raster), 10)\n      xy <- xyFromCell(raster, cells)\n      sp <- SpatialPoints(xy, proj4string=crs(colven))\n      # And then use rgeos\n      \n      library(rgeos)\n      # inside Colombia only\n      col <- colven[colven$NAME == \"Colombia\", ]\n      sp <- gIntersection(sp, col)\n      \n      # get the border between Venezuela and Colombia\n      ven <- colven[colven$NAME == \"Venezuela\", ]\n      border <- gIntersection(col, ven)\n      \n      # get the distance\n      # this fails for me, that seems to be a bug in rgeos for these data\n      gDistance(sp, border, byid=TRUE)  ",
    "created" : 1504495815826.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4038687554",
    "id" : "3E9C424B",
    "lastKnownWriteTime" : 1504682818,
    "last_content_update" : 1504682818922,
    "path" : "~/R_Projects/map/Rfile/testOthers.R",
    "project_path" : "Rfile/testOthers.R",
    "properties" : {
        "source_window_id" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 22,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}